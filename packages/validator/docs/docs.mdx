---
name: UiValidator
menu: Utils
---

import { Props, Playground } from 'docz';

import * as packageJson from '../package.json';

import { UiValidator } from '../src/';
import { ValidatorRunner } from './util/validator';

import { UiText } from '@uireact/text';
import { UiList } from '@uireact/list';
import { UiFlexGrid } from '@uireact/flex-grid';
import { UiCard } from '@uireact/card';

# UiValidator

<sup>
  <a href="https://github.com/inavac182/ui-react/blob/main/packages/validator/" target="_blank">
    v{packageJson.version}
  </a>
</sup>

> Validator class that run checks based on a given schema into a given object. Used commonly to validate forms in client and data sets on the server side.
> We make use of chainable functions so the schema creation is simple and easy.

## Installation ‚öôÔ∏è

> npm i -S @uireact/validator

## Usage üéÆ

First, we need to create an instance of the `UiValidator`

```tsx
import { UiValidator } from '@uireact/validator';

const validator = new UiValidator();
```

Then, we will create our schema, For this we need to create an object and use `validator.rulers()` which returns a `UiRuler` class
with chainable functions that together builds the rule for that field:

```tsx
import { UiValidator } from '@uireact/validator';

const validator = new UiValidator();

const schema = {
  firstName: validator.ruler().isRequired('First Name is required').length(0, 10, 'First name is not valid'),
  email: validator.ruler().isRequired('Phone is required').type('phone', 'Phone is not valid'),
};
```

All chainable functions have 2 common attributes `errorMessage` and `errorCode`, these are used to provide a message or a code if the validation fails.

Then, we can simple call the function `validator.validate()` passing our schema and our data object to be validated:

```tsx
import { UiValidator } from '@uireact/validator';

const validator = new UiValidator();

const schema = {
  firstName: validator.ruler().isRequired('First Name is required').length(0, 10, 'First name is not valid'),
  email: validator.ruler().isRequired('Phone is required').type('phone', 'Phone is not valid'),
};

const data = {
  firstName: 'Felipe',
  email: 'test@mymail.com',
};

const result = validator.validate(schema, data);
```

The result will follow [UiValidatorResult](https://github.com/inavac182/uireact/blob/main/packages/validator/src/types/validator-result.ts#L16) structure. Basically 2 top level fields:

```ts
/** The result of the validation */
export type UiValidatorResult = {
  /** If validation was success or not */
  passed: boolean;
  /** The list of errors found in the data passed keyed by the field name */
  errors?: UiValidatorErrors;
};
```

So, for a overall validation result `passed` will give you that, for specific errors from the validation `errors` field will have that object with a list of all errors found per each field,
you can then decide how and which ones to show to your user.

export const validator = new UiValidator();

## Example üí°

Example using a component that receives the schema and the data and then renders a message if it passes:

<Playground>
  <ValidatorRunner
    schema={{
      age: validator
        .ruler()
        .isRequired('The age is required')
        .range(25, 35, 'This only works for ppl from 25 to 35 years old'),
      firstName: validator.ruler().isRequired('First Name is required').length(0, 10, 'First name is not valid'),
      email: validator.ruler().isRequired('Email is required').type('email', 'Email is not valid'),
    }}
    data={{ age: 29, firstName: 'Felipe', email: 'text@mymail.com' }}
  />
</Playground>

<small>ValidatorRunner is just for demo purposes this package only exports the UiValidator class.</small>

## Details ü§ì

These are the chainable functions that you can use, to set the rules, their possible values and examples:

<table>
  <tr>
    <th>Rule</th>
    <th>Options</th>
    <th>Validates</th>
  </tr>
  <tr>
    <td>isRequired()</td>
    <td>
      <UiList>
        <li> ‚ùì errorMessage</li>
        <li> ‚ùì errorCode </li>
      </UiList>
    </td>
    <td>
      <UiList>
        <li>‚ùå null</li>
        <li>‚ùå undefined</li>
        <li>‚úÖ everything else</li>
      </UiList>
    </td>
  </tr>
  <tr>
    <td>type()</td>
    <td>
      <UiList>
        <li>
          ‚ùóÔ∏è type
          <UiList>
            <li>&nbsp;&nbsp; string</li>
            <li>&nbsp;&nbsp; numeric</li>
            <li>&nbsp;&nbsp; phone</li>
            <li>&nbsp;&nbsp; email</li>
          </UiList>
        </li>
        <li></li>
        <li> ‚ùì errorMessage</li>
        <li> ‚ùì errorCode </li>
      </UiList>
    </td>
    <td>
      <UiList>
        <li>
          string
          <UiList>
            <li>&nbsp;&nbsp; ‚úÖ string type</li>
            <li>&nbsp;&nbsp; ‚ùå everything else</li>
          </UiList>
        </li>
        <li>
          numeric
          <UiList>
            <li>&nbsp;&nbsp; ‚úÖ number type</li>
            <li>&nbsp;&nbsp; ‚úÖ strings that can be parsed as number</li>
            <li>&nbsp;&nbsp; ‚ùå everything else</li>
          </UiList>
        </li>
        <li>
          phone
          <UiList>
            <li>&nbsp;&nbsp; ‚úÖ All phones with most common patterns</li>
            <li>
              <small>
                &nbsp;&nbsp; *This is intended to validate most of the American and European areas. More info underneath
                this table.
              </small>
            </li>
          </UiList>
        </li>
        <li>
          email
          <UiList>
            <li>&nbsp;&nbsp; ‚úÖ Using . or _ or - in their name (test.n-a_me@domain.com)</li>
            <li>&nbsp;&nbsp; ‚úÖ Emails using 2-3 digits for top level domain (.com || .mx)</li>
            <li>&nbsp;&nbsp; ‚úÖ With top level domain and regional domain (.co.uk)</li>
            <li>&nbsp;&nbsp; ‚ùå everything else</li>
          </UiList>
        </li>
      </UiList>
    </td>
  </tr>
  <tr>
    <td>range()</td>
    <td>
      <UiList>
        <li> ‚ùóÔ∏è min</li>
        <li> ‚ùóÔ∏è max</li>
        <li> ‚ùì errorMessage</li>
        <li> ‚ùì errorCode </li>
      </UiList>
    </td>
    <td>
      <UiList>
        <li>‚úÖ If the NUMBER is bigger or equal than min and smaller or equal than max.</li>
        <li>‚ùå Everything else</li>
      </UiList>
    </td>
  </tr>
  <tr>
    <td>length()</td>
    <td>
      <UiList>
        <li> ‚ùóÔ∏è min</li>
        <li> ‚ùóÔ∏è max</li>
        <li> ‚ùì errorMessage</li>
        <li> ‚ùì errorCode </li>
      </UiList>
    </td>
    <td>
      <UiList>
        <li>‚úÖ If the STRING is longer or equal than min and shorter or equal than max.</li>
        <li>‚ùå Everything else</li>
      </UiList>
    </td>
  </tr>
</table>

## Phone validation üì±

The phone validation is pretty extensive so we better have it very clear what values are positive in our validator so you know what to expect:

{' '}
<table>
  <tr>
    <th>Country code</th>
    <th>Area code</th>
    <th>The rest</th>
  </tr>
  <tr>
    <td>
      <UiList>
        <li>‚úÖ Not present</li>
        <li>‚úÖ 1 digit</li>
        <li>‚úÖ 2 digits</li>
        <li>‚úÖ 3 digits</li>
        <li>‚úÖ with + sign</li>
        <li>‚ùå everything else</li>
      </UiList>
    </td>
    <td>
      <UiList>
        <li>‚úÖ 1 digit </li>
        <li>‚úÖ 2 digits</li>
        <li>‚úÖ 3 digits</li>
        <li>‚úÖ with parenthesis</li>
        <li>‚úÖ with hyphen after it</li>
        <li>‚úÖ with space after it</li>
        <li>‚úÖ with dot after it</li>
        <li>‚ùå everything else</li>
      </UiList>
    </td>
    <td>
      <UiList>
        <li>‚úÖ 7 digits </li>
        <li>‚úÖ all together</li>
        <li>‚úÖ with hyphens after the 3 digit</li>
        <li>‚úÖ with spaces after the 3 digit</li>
        <li>‚úÖ with dot after the 3 digit</li>
        <li>‚ùå everything else</li>
      </UiList>
    </td>
  </tr>
</table>

A few examples of valid patterns:

<UiCard>
  <UiFlexGrid justifyContent="space-between">
    <UiList>
      <li>17352344980</li>
      <li>+1 7352344980</li>
      <li>1 735 2344980</li>
      <li>1 735 234 4980</li>
      <li>1 (735) 234 4980</li>
      <li>1 735-234-4980</li>
    </UiList>
    <UiList>
      <li>+1-735-234-4980</li>
      <li>1.735.234.4980</li>
      <li>1 735 234.4980</li>
      <li>1 (735) 234.4980</li>
      <li>735 234.4980</li>
      <li>735 234 4980</li>
    </UiList>
    <UiList>
      <li>735 2344980</li>
      <li>7352344980</li>
      <li>735.234.4980</li>
      <li>735-234-4980</li>
      <li>735-2344980</li>
      <li>(735) 2344980</li>
    </UiList>
  </UiFlexGrid>
</UiCard>

<br />

We tried to cover a lot of cases but sometimes the truth is that for phones we could make our applications a bit smarter
for instance the country code be selected rather than typed, that way you format it the way you need it. Then you only allow for numbers
that way there are no weird characters in the phone and finally check for the length of the phone.

Said that, the ultimate validation for phons is always SMS verification that way you know for sure the phone is valid.

So, Maybe this rule would make the work for you without worrying about formats:

```ts
const schema = {
  phone: validator.ruler().isRequired().type('numeric').length(10, 12),
};
```
